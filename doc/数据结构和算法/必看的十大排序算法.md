# 面霸篇：必看的十大排序算法

身为程序员，十大排序是是所有合格程序员所必备和掌握的，并且热门的算法比如快排、归并排序还可能问的比较细致，对算法性能和复杂度的掌握有要求。
码哥作为一个负责任的 Java 和数据结构与算法方向的小博主，在这方面肯定不能让读者们有所漏洞。
跟着本篇走，带你捋一捋常见的十大排序算法，轻轻松松掌握！
首先对于排序来说大多数人对排序的概念停留在冒泡排序或者JDK中的Arrays.sort()，手写各种排序对很多人来说都是一种奢望，更别说十大排序算法了，不过还好你遇到了本篇文章！
对于排序的分类，主要不同的维度比如复杂度来分、内外部、比较非比较等维度来分类。
我们正常讲的十大排序算法是内部排序，我们更多将他们分为两大类：基于「**比较和非比较**」这个维度去分排序种类。

## 非比较类

「非比较类的有桶排序、基数排序、计数排序」。也有很多人将排序归纳为8大排序，那就是因为基数排序、计数排序是建立在桶排序之上或者是一种特殊的桶排序，但是基数排序和计数排序有它特有的特征，所以在这里就将他们归纳为10种经典排序算法。而比较类排序也可分为

## 比较类

比较类排序也有更细致的分法，有基于交换的、基于插入的、基于选择的、基于归并的，更细致的可以看下面的脑图。

图见：[十大排序算法.png]

### 交换类

#### 冒泡排序
冒泡排序，又称起泡排序，它是一种基于交换的排序典型，也是快排思想的基础，冒泡排序是一种稳定排序算法，时间复杂度为O(n^2).基本思想是：「循环遍历多次每次从前往后把大元素往后调，每次确定一个最大(最小)元素，多次后达到排序序列。」(或者从后向前把小元素往前调)。

具体思想为(把大元素往后调)：

从第一个元素开始往后遍历，每到一个位置判断是否比后面的元素大，如果比后面元素大，那么就交换两者大小，然后继续向后，这样的话进行一轮之后就可以保证「最大的那个数被交换交换到最末的位置可以确定」。

第二次同样从开始起向后判断着前进，如果当前位置比后面一个位置更大的那么就和他后面的那个数交换。但是有点注意的是，这次并不需要判断到最后，只需要判断到倒数第二个位置就行(因为第一次我们已经确定最大的在倒数第一，这次的目的是确定倒数第二)

同理，后面的遍历长度每次减一，直到第一个元素使得整个元素有序。

#### 快速排序

快速排序是对冒泡排序的一种改进，采用递归分治的方法进行求解。而快排相比冒泡是一种不稳定排序,时间复杂度最坏是O(n^2),平均时间复杂度为O(nlogn),最好情况的时间复杂度为O(nlogn)。

对于快排来说，「基本思想」是这样的

快排需要将序列变成两个部分，就是「序列左边全部小于一个数」，「序列右面全部大于一个数」，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。
其中这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是「通常」不优化情况我们取最左边的那个数。

### 插入类排序

直接插入排序

详细还得看具体的文章进行分析














































