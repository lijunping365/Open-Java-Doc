# volatile是什么意思？干什么用的？
是java虚拟机提供的轻量级的同步机制。保证可见性，不保证原子性，禁止指令重排。

## volatile的可见性
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（也叫栈空间），工作内存是每个线程的私有数据区域，
而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行。操作过程有三步。

> 1.首先要将变量从主内存拷贝到自己的工作内存空间。
> 2.然后对变量进行操作。
> 3.操作完成后再将变量写回主内存，不能直接操作主内存中的变量。

各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，
线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下。
图见：[volatile可见性原理图.png]

## volatile的不保证原子性
原子性定义：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要具体完成，要么同时成功，要么同时失败。
volatile不保证原子性原理图见：[volatile不保证原子性原理图.png]
如何让volatile保证原子性

> 1.最简单的方法，加sync的锁。
> 2.可以使用JUC下面的原子包装类。

## volatile禁止指令重排

单线程环境里面确保最终执行结果和代码顺序的结果一致
处理器在进行重排序时，必须要考虑指令之间的数据依赖性
多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

```
public void mySort() {
	int x = 11;
	int y = 12;
	x = x + 5;
	y = x * x;
}
```

按照正常单线程环境，执行顺序是 1 2 3 4

但是在多线程环境下，可能出现以下的顺序：

2 1 3 4
1 3 2 4

上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样

但是指令重排也是有限制的，即不会出现下面的顺序

4 3 2 1
因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性

因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行

## volatile 常见使用场景

> 1.DCL 单例对象双重检查--防止指令重排

























































