# 并发编程的三要素包括：原子性、可见性、有序性。

```text
java的并发编程是基于多线程的
（1）原子性，原子性就是能够保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等该线程处理完数据后才能进行；   
（2）可见性，Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。
（3）指令重排，在程序执行过程中为了性能考虑,，编译器和 CPU 可能会对指令重新排序。对于并发多线程场景下，指令重排会产生不确定的执行效果。
```
## 什么是原子性

由于I/O的速度太慢，早期的操作系统发明了多进程，就是允许某个进程执行一小段时间后，重新选择一个进程来执行，这个过程叫做任务切换，而这一小段的时间我们称其为时间片。
现在操作系统的任务切换一般指的是更轻量级的线程切换，java的并发编程是基于多线程的，自然也会存在线程切换。
一般会在时间片结束的时候进行线程切换，java语言中执行的一段简单的代码往往需要多条CPU的指令实现，比如count++这部分代码，至少需要三条CPU指令：
1.首先把count从内存中读取到CPU的寄存器中
2.在寄存器中执行+1操作
3.最后将count的值写入内存中（可能写入到CPU的缓存中）

而线程切换是可以发生在任意的一条CPU指令执行之后的，注意，这里说的是CPU的指令，而不是java语言中的指令，对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图[线程切换cpu.png]的顺序执行，那么我们会发现两个线程都执行了 count++ 的操作，但是得到的结果不是我们期望的 2，而是 1。
这就是线程切换导致的数据错误问题，我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。
因此，很多时候我们需要在高级语言层面保证操作的原子性。
代码示例：最终 count 可能小于 200
```java
public class NoSynchronizedTest {

  private static int count = 0;

  public static void main(String[] args) {
    for (int i = 0; i < 200; i++) {
      new Thread(() -> {
        try {
          Thread.sleep(10);
          count++;
        } catch (Exception e) {
          e.printStackTrace();
        }
      }).start();
    }
    try {
      Thread.sleep(200);
    } catch (Exception e) {
      e.printStackTrace();
    }
    System.out.println(count);
  }

}
```

## 什么是可见性

首先我们就来看看什么是可见性。
一个线程对共享变量的修改，另一个线程可以感知到，我们称其为可见性。
在单核时代，其实是不存在可见性问题的，因为所有的线程都是在一个CPU中工作的，一个线程的写操作对于其他的线程一定是可见的。
但是多核CPU出现后，每个CPU都有自己的缓存，多个线程在不同的CPU中处理数据就会导致不可见问题。
假设变量v的值是1， 两个线程同时执行了v++操作，首先会从内存中读取变量v的数据到各自的CPU缓存中，这个时候两个CPU缓存中的v都是1，执行v++后，两个变量v都变成了2，然后再写回内存，内存中的变量v就变成了2。
但其实我们想看到的结果v最终应该是3才对。
在CPU1缓存中执行v++后，CPU2缓存无法感知的到，这就是可见性问题。而由于可见性问题导致的最终数据不正确，就是线程安全问题。

## 什么是有序性
有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“x=1；y=2；”编译器优化后可能变成“y=2；x=1；”。
在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候调整了语句的顺序可能导致意想不到的 Bug。
在 Java 领域一个经典的案例就是利用双重检查创建单例对象，代码如下：
```java
public class Singleton {
 static Singleton instance;
 static Singleton getInstance(){
  if (instance == null) {
   synchronized(Singleton.class) {
    if (instance == null)
     instance = new Singleton();
    }
  }
  return instance;
 }
}
```
假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。
这个过程看上去是不是无懈可击，没有漏洞？
答案是否定的，问题就出在了new操作上，我们以为的new操作是这样的：
1.分配一块内存空间
2.在这块内存空间上初始化Singleton实例对象
3.把这个对象的内存地址赋值给instance变量

但实际上由于指令重排，优化后的过程是这样的：
1.分配一块内存空间
2.把这快内存空间的内存地址赋值给instance变量
3.在这块内存空间上初始化Singleton实例对象 
那么这样调换顺序后会发生什么呢？
我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。 

## 总结
使用并发编程开发，往往会出现很多难以找到原因的BUG，通过对可见性、有序性和原子性的分析，可以为我们排查并发导致的BUG提供一些思路。
CPU缓存会导致可见性
指令重排会导致有序性
线程切换会导致原子性


# 线程的组成
线程ID：线程标识符。
当前指令指针（PC）：指向要执行的指令。
寄存器集合：存储单元寄存器的集合。
堆栈：暂时存放数据和地址，一般用来保护断点和现场。

# 线程的状态
[线程状态2.png]
我们看到 Java 源代码里面，线程状态的枚举有如下 6 个。
```java
public enum State {

 //新建状态
 NEW,

 //运行状态
 RUNNABLE,

 //阻塞状态
 BLOCKED,

 //等待状态
 WAITING,

 //等待状态（区别在于这个有等待的时间）
 TIMED_WAITING,

 //终止状态
 TERMINATED;
}
```
NEW：新建状态。在创建完 Thread ，还没执行 start() 之前，线程的状态一直是 NEW。可以说这个时候还没有真正的一个线程映射着，只是一个对象。

RUNNABLE：运行状态。线程对象调用 start() 之后，就进入 RUNNABLE 状态，该状态说明在 JVM 中有一个真实的线程存在。

BLOCKED：阻塞状态。线程在等待锁的释放，也就是等待获取 monitor 锁。

WAITING：等待状态。线程在这个状态的时候，不会被分配 CPU，而且需要被显示地唤醒，否则会一直等待下去。

TIMED_WAITING：超时等待状态。这个状态的线程也一样不会被分配 CPU，但是它不会无限等待下去，有时间限制，时间一到就停止等待。

TERMINATED：终止状态。线程执行完成结束，但不代表这个对象已经没有了，对象可能还是存在的，只是线程不存在了。

我们 new 出线程类的时候，就是 NEW 状态，调用 start() 方法，就进入了 RUNNABLE 状态，这时如果触发等待，则进入了 WAITING 状态，如果触发超时等待，则进入 TIMED_WAITING 状态，当访问需要同步的资源时，则只有一个线程能访问，其他线程就进入 BLOCKED 状态，当线程执行完后，进入 TERMINATED 状态。








































































