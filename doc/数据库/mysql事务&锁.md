# mysql 事务

## 事务的 4 个特性

1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。

2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。

3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

## 事务并发可能产生的问题：(在不考虑事务隔离的情况下)，就是多个事物并发执行时可能出现的现象：
脏读：事物A中读取到了事物B已经修改，但是还没提交的数据，如果事物B回滚了，这些数据就是脏数据，称之为脏读。

不可重复读：事物A中相同的条件查询数据，多次查询出来的值不一样，原因是事物B在两次查询的中间修改了数据。

幻读：事物A中相同的条件查询数据，多次查询出来的数据条数不一样，原因是事物B在两次查询的中间添加或者删除了数据。

不可重复读与幻读表现出来的都是查询结果不一致，一个侧重的是值被修改，一个侧重的是数据条数发生了变化；解决不可重复读需要锁住满足条件的记录，解决幻读需要锁表

## mysql 事物的4个隔离级别：

Read Uncommitted（读取未提交内容）：
该隔离级别，所有事务都可以看到其他未提交事务的执行结果。容易产生脏读，基本无用。

Read Committed（读取提交内容）：
大多数数据库的默认事务隔离级别，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。

Repeatable Read（可重读）：
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。

Serializable（串行化）：
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

**四种隔离级别，分别有可能产生问题如下所示：**
![](mysql事务隔离级别.jpg)

注意：要区分事务并发产生的现象与mysql 事务的 4 个隔离级别

## 查询 mysql 的事务隔离级别：
SELECT @@transaction_isolation;

## mysql 的默认事务隔离级别：
REPEATABLE-READ（可重复读）

## 修改 mysql 的事务隔离级别
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]

对当前session修改，在登录mysql客户端后，执行命令：
set session transaction isolation level read uncommitted;


## 再来说说锁机制：
**共享锁**：由读表操作加上的锁，加锁后其他用户只能获取该表或行的共享锁，不能获取排它锁，也就是说只能读不能写

**排它锁**：由写表操作加上的锁，加锁后其他用户不能获取该表或行的任何锁，典型是案例如下：
```sql
select product_stock from slwnkj_product where product_id = #{productId} for update
// 执行完这句以后
1）当其他事务想要获取共享锁，比如事务隔离级别为SERIALIZABLE的事务，执行
select * from user;

将会被挂起，因为SERIALIZABLE的select语句需要获取共享锁

2）当其他事务执行
select * from user where userId = 1 for update;

update user set userAge = 100 where userId = 1;  

也会被挂起，因为for update会获取这一行数据的排它锁，需要等到前一个事务释放该排它锁才可以继续进行       
```

**锁的范围:**
行锁: 对某行记录加上锁

表锁: 对整个表加上锁

这样组合起来就有,行级共享锁,表级共享锁,行级排他锁,表级排他锁
 
下面来说说不同的事务隔离级别的实例效果，例子使用InnoDB，开启两个客户端A，B，在A中修改事务隔离级别，在B中开启事务并修改数据，然后在A中的事务查看B的事务修改效果(两个客户端相当于是两个连接，在一个客户端中的修改参数变量的值是不会影响到另外的一个客户端的)：

 

1.READ-UNCOMMITTED(读取未提交内容)级别

　　1)A修改事务级别并开始事务，对user表做一次查询

　　　

 

　　2)B更新一条记录

　　　

 

　　3）此时B事务还未提交，A在事务内做一次查询，发现查询结果已经改变

　　　

 

　　4）B进行事务回滚

　　　

 

　　5）A再做一次查询，查询结果又变回去了

　　　

 

　　6）A表对user表数据进行修改

　　　

 

　　7）B表重新开始事务后，对user表记录进行修改，修改被挂起，直至超时，但是对另一条数据的修改成功，说明A的修改对user表的数据行加行共享锁(因为可以使用select)

　　　

 

　　可以看出READ-UNCOMMITTED隔离级别，当两个事务同时进行时，即使事务没有提交，所做的修改也会对事务内的查询做出影响，这种级别显然很不安全。但是在表对某行进行修改时，会对该行加上行共享锁

 

2. READ-COMMITTED（读取提交内容）

　　1）设置A的事务隔离级别，并进入事务做一次查询

　　　

 

　　2）B开始事务，并对记录进行修改

　　　

 

　　3）A再对user表进行查询，发现记录没有受到影响

　　　

 

　　4）B提交事务

　　　

 

　　5）A再对user表查询，发现记录被修改

　　　

 

　　6）A对user表进行修改

　　　

 

　　7）B重新开始事务，并对user表同一条进行修改，发现修改被挂起，直到超时，但对另一条记录修改，却是成功，说明A的修改对user表加上了行共享锁(因为可以select)

　　　

　　　

 

　　READ-COMMITTED事务隔离级别，只有在事务提交后，才会对另一个事务产生影响，并且在对表进行修改时，会对表数据行加上行共享锁

 

3. REPEATABLE-READ(可重读)

　　1）A设置事务隔离级别，进入事务后查询一次

　　　

 

　　2）B开始事务，并对user表进行修改

　　　

 

　　3）A查看user表数据，数据未发生改变

　　　

 

　　4）B提交事务

　　　

 

　　5）A再进行一次查询，结果还是没有变化

　　　

 

　　6）A提交事务后，再查看结果，结果已经更新

　　　

 

　　7）A重新开始事务，并对user表进行修改

　　　

　　　

　　8）B表重新开始事务，并对user表进行修改，修改被挂起，直到超时，对另一条记录修改却成功，说明A对表进行修改时加了行共享锁(可以select)

　　　

　　　

 

　　REPEATABLE-READ事务隔离级别，当两个事务同时进行时，其中一个事务修改数据对另一个事务不会造成影响，即使修改的事务已经提交也不会对另一个事务造成影响。

　　在事务中对某条记录修改，会对记录加上行共享锁，直到事务结束才会释放。

 

4.SERIERLIZED(可串行化)

　　1）修改A的事务隔离级别，并作一次查询

　　　

 

　　2）B对表进行查询，正常得出结果，可知对user表的查询是可以进行的

　　　

 

　　3）B开始事务，并对记录做修改，因为A事务未提交，所以B的修改处于等待状态，等待A事务结束，最后超时，说明A在对user表做查询操作后，对表加上了共享锁

　　　

 

　　SERIALIZABLE事务隔离级别最严厉，在进行查询时就会对表或行加上共享锁，其他事务对该表将只能进行读操作，而不能进行写操作。